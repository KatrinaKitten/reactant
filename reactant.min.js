// Reactant v0.1.0 - Created by Katrina Scialdone
// Heavily based on Github's Catalyst framework: https://github.github.io/catalyst
export const version="0.1.0";export default function reactant(elementClass,{tagName,templateName,useShadowRoot=true,attrs=[],targets=[]}={}){const connect=elementClass.prototype.connectedCallback;elementClass.prototype.connectedCallback=function(){let templateElement=document.querySelector(`template[name="${templateName??this.constructor.tagName }"]`);if(templateElement){if(useShadowRoot){this.attachShadow({mode:'open'}).append(templateElement.content.cloneNode(true))}else{this.append(templateElement.content.cloneNode(true))}}for(let attr of attrs){let descriptor=getAttrDescriptor(this,attr),value;value=attr in this?this[attr]:'';Object.defineProperty(this,attr,descriptor);if(!this.hasAttribute(getAttrName(attr))){descriptor.set.call(this,value)}else{this[attr]=descriptor.get.call(this)}}connect?.call(this);for(let target of targets){let discover=this[target]instanceof Array?findTargets:findTarget;Object.defineProperty(this,target,{configurable:true,get(){return discover(this,target)}})}const observer=new MutationObserver(mutations=>{for(let mutation of mutations){if(mutation.type==='attributes'&&mutation.target instanceof Element){bindActions(mutation.target)}if(mutation.type==='childList'&&mutation.addedNodes.length){for(let node of mutation.addedNodes){if(node instanceof Element){bindActionsDeep(node)}}}}});this.unwatchActions=()=>observer.disconnect();observer.observe(this,{childList:true,subtree:true,attributeFilter:['data-action']});if(this.shadowRoot){observer.observe(this.shadowRoot,{childList:true,subtree:true,attributeFilter:['data-action']})}bindActionsDeep(this);bindActionsDeep(this.shadowRoot)};elementClass.observedAttributes=attrs.map(getAttrName).concat(elementClass.observedAttributes??[]);elementClass.tagName=tagName??elementClass.name.replace(/([A-Z]($|[a-z]))/g,'-$1').replace(/(^-|-Element$)/g,'').toLowerCase();window.customElements.define(elementClass.tagName,elementClass)}function getAttrName(name){return `data-${name.replace(/([A-Z]($|[a-z]))/g,'-$1')}`.replace(/--/g,'-').toLowerCase()}function getAttrDescriptor(instance,name){const attrName=getAttrName(name);switch(typeof instance[name]){case 'number':return{get(){return Number(this.getAttribute(attrName)??0)},set(newValue){return this.setAttribute(attrName,Number(newValue))}};case 'boolean':return{get(){return this.hasAttribute(attrName)},set(newValue){return this.toggleAttribute(attrName,!!newValue)}};default:return{get(){return this.getAttribute(attrName)??''},set(newValue){return this.setAttribute(attrName,newValue??'')}}}}function bindActionsDeep(root){if(!root){return}for(let el of root.querySelectorAll('[data-action]')){bindActions(el)}if(root instanceof Element&&root.dataset.action){bindActions(root)}}function bindActions(el){el.__reactantActionAborter?.abort();if(!el.dataset.action){return}el.__reactantActionAborter=new AbortController();let actions=(el.dataset.action??'').trim().split(/\s+/);for(let action of actions){let actionObj={event:action.split(':')[0],target:action.split(':')[1].split('#')[0],method:action.split('#')[1]};el.addEventListener(actionObj.event,handleAction(actionObj),{signal:el.__reactantActionAborter.signal})}}function handleAction(action){return function(event){let target=event.target.closest(action.target);if(target){return target[action.method]?.(event)}target=event.target.getRootNode()?.host;if(target&&target.matches(action.target)){return target[action.method]?.(event)}}}function findTarget(element,name){let tag=element.constructor.tagName;if(element.shadowRoot){for(let child of element.shadowRoot.querySelectorAll(`[data-target~="${ tag }.${ name }"]`)){if(!child.closest(tag)){return child}}}for(let child of element.querySelectorAll(`[data-target~="${ tag }.${ name }"]`)){if(child.closest(tag)===element){return child}}}function findTargets(element,name){let tag=element.constructor.tagName;let targets=[];if(element.shadowRoot){for(let child of element.shadowRoot.querySelectorAll(`[data-target~="${ tag }.${ name }"]`)){if(!child.closest(tag)){targets.push(child)}}}for(let child of element.querySelectorAll(`[data-target~="${ tag }.${ name }"]`)){if(child.closest(tag)===element){targets.push(child)}}return targets}
